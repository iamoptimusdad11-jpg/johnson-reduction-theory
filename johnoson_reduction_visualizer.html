<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Johnson Reduction Visualizer — Darkglass Final (Superposition Dot)</title>
<style>
  :root{
    --bg-1:#06060a; --bg-2:#0f1724; --accent:#7c6cff; --muted:rgba(255,255,255,0.65);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));font-family:Inter,Arial,sans-serif;color:#e9eef8}
  .app { max-width:980px; margin:18px auto; padding:18px; }

  header.top{ display:flex; align-items:center; gap:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px 16px; border-radius:12px; backdrop-filter: blur(10px); box-shadow: 0 6px 30px rgba(3,6,18,0.6); }
  .menu-btn{ font-size:20px; padding:8px 10px; border-radius:10px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); cursor:pointer; color:var(--accent) }
  h1{ margin:0; font-size:1.1rem; color:#f5f7ff; }

  .main-grid { display:grid; grid-template-columns: 1fr 360px; gap:16px; margin-top:16px; }
  @media (max-width:920px){ .main-grid{ grid-template-columns: 1fr; } }

  .panel { background: rgba(255,255,255,0.03); border-radius:12px; padding:14px; box-shadow: 0 8px 30px rgba(2,6,20,0.6); border:1px solid rgba(255,255,255,0.03); backdrop-filter: blur(10px); }
  label{ display:block; font-size:0.85rem; color:var(--muted); margin-bottom:8px; }
  input[type="number"], select { width:100%; padding:12px 10px; border-radius:10px; border:none; background: rgba(255,255,255,0.03); color:#f7f9ff; font-size:1rem; outline:none; }

  .row { display:flex; gap:10px; margin-top:10px; }
  .row > * { flex:1; }

  .result-box { margin-top:12px; padding:12px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:0.95rem; color:#e8f0ff; white-space:pre-wrap; }

  .spinner-wrap{ margin-top:14px; display:flex; justify-content:center; align-items:center; }
  .glass-frame{ width:360px; max-width:92%; aspect-ratio:1/1; border-radius:18px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); box-shadow: 0 12px 40px rgba(0,0,0,0.6); padding:12px; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; backdrop-filter: blur(12px) saturate(120%); }

  #viz{ width:100%; height:100%; display:block; }

  .meta { margin-top:12px; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); border:1px solid rgba(255,255,255,0.02); color:#dfe9ff; font-size:0.95rem; line-height:1.4; white-space:pre-wrap; }

  .side-doc { position:relative; padding:12px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); backdrop-filter: blur(8px); }
  .side-doc h3{ margin-top:0; font-size:1rem; color:#fff; }
  .side-doc p{ color:var(--muted); font-size:0.93rem; margin:8px 0; }

  .full-sidebar { position:fixed; left:0; top:0; bottom:0; width:340px; transform:translateX(-110%); background: linear-gradient(180deg, rgba(12,15,25,0.96), rgba(8,10,18,0.98)); box-shadow: 6px 0 30px rgba(0,0,0,0.7); padding:18px; z-index:1200; transition:transform 0.32s; overflow:auto; border-right:1px solid rgba(255,255,255,0.03); }
  .full-sidebar.open { transform:translateX(0); }
  .close-side { position:absolute; right:12px; top:12px; background:transparent; border:1px solid rgba(255,255,255,0.03); color:var(--muted); padding:6px 8px; border-radius:8px; cursor:pointer; }

  .overlay { position:fixed; inset:0; background:rgba(0,0,0,0.45); opacity:0; pointer-events:none; transition:opacity 0.22s; z-index:1100; }
  .overlay.show { opacity:1; pointer-events:all; }
  .muted { color:var(--muted); font-size:0.9rem; }
  a.small-btn { display:inline-block; padding:8px 10px; border-radius:8px; background:rgba(255,255,255,0.02); color:#eaf0ff; text-decoration:none; border:1px solid rgba(255,255,255,0.03) }
</style>
</head>
<body>
  <div class="app">
    <header class="top">
      <button class="menu-btn" id="openSidebarBtn" aria-label="Open menu">☰</button>
      <h1>Johnson Reduction Visualizer — Darkglass</h1>
    </header>

    <div class="main-grid">
      <div>
        <div class="panel">
          <label for="num">Enter a number (0–100) — digits only</label>
          <input id="num" type="number" min="0" max="100" placeholder="e.g. 19" inputmode="numeric" aria-label="Number input">

          <div class="row">
            <select id="modeSelect" aria-label="Mode select">
              <option value="johnson">Johnson Mode</option>
              <option value="numerology">Numerology Mode</option>
            </select>

            <select id="infinitySelect" aria-label="Infinity mode select">
              <option value="open">Open Infinity Mode</option>
              <option value="closed">Closed Infinity Mode</option>
            </select>
          </div>

          <div class="row" style="margin-top:8px;">
            <label style="margin:0;display:flex;align-items:center;gap:8px;font-size:0.9rem;color:var(--muted);">
              <input id="forceMasters" type="checkbox" style="transform:scale(1.1);margin-right:6px;">
              Force reduce masters (11 → 2) in Numerology Mode
            </label>
          </div>

          <div class="result-box" id="resultBox">Result will appear here.</div>

          <div class="spinner-wrap" style="margin-top:12px;">
            <div class="glass-frame">
              <canvas id="viz" width="800" height="800" aria-label="Geometric visualization"></canvas>
            </div>
          </div>

          <div class="meta" id="metaBox">Metaphysical description will appear here.</div>
        </div>
      </div>

      <div class="side-doc panel">
        <h3>Quick Reference</h3>
        <p class="muted"><strong>Core rules (Open Infinity):</strong> 0→1, 19→10, 10→1, 1→1 — else numbers stay unless reduced by numerology.</p>
        <p class="muted"><strong>Johnson Mode</strong> uses Johnson reduction mapping (special cases). <strong>Numerology Mode</strong> reduces by digit-sum (11/22/33 preserved unless forced).</p>
        <p class="muted">Shapes: 1 = dot (superposition chaotic); 2 = line; 3+ = exact polygon with that many sides. Spin speed increases (doubled) with the final number.</p>
        <p class="muted">Open the full sidebar for theory notes and examples.</p>
      </div>
    </div>
  </div>

  <div id="fullSidebar" class="full-sidebar" aria-hidden="true">
    <button class="close-side" id="closeSidebarBtn">Close ✕</button>
    <h2>Johnson Reduction Theory — Full Notes</h2>

    <p class="muted"><strong>Core Axioms</strong></p>
    <ul class="muted">
      <li>0 = 1</li>
      <li>19 = 10 (if aleph-null = ashtei-asar-null)</li>
      <li>10 = 1</li>
      <li>1 = 1 (fixed point)</li>
    </ul>

    <p class="muted"><strong>11 Behavior Summary</strong><br>
      • Numerology Mode: 11 preserved by default as master; check <em>Force reduce masters</em> to collapse 11 → 2.<br>
      • Johnson Mode: in <em>Open Infinity</em>, 11 → 11-null → 1 (visualized). In <em>Closed Infinity</em>, 11 → 2.
    </p>

    <p class="muted"><strong>Visualization Notes</strong><br>
      Shapes map exactly to the numeric value (Option A). Number 1 is a hyper-chaotic superposition dot — aggressive random motion, rapid color shifts, and occasional state-collapse flash. High-sided polygons gain stronger glow, thicker outlines, slight radius growth and subtle breathing so they remain visually striking.
    </p>
    <hr />
    <p class="muted">Designer notes: spin speed is doubled relative to base mapping and capped sensibly so the animation remains usable. Use the controls to experiment.</p>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true"></div>

<script>
/* ---------------- Utilities ---------------- */
const clampNum = (v,min,max) => Math.max(min, Math.min(max, Number(v)|0));
function randRange(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* ---------------- Metaphysical mapping 0-100 (short phrases) ---------------- */
const metaphysicalMap = (function(){
  const map = {};
  map[0]="Zero • Potential (Closed Infinity: remains 0; Open Infinity: collapses to 1)";
  map[1]="Origin • Self • Spark (Superposition chaotic dot)";
  map[2]="Duality • Mirror • Balance";
  map[3]="Creation • Expression • Flow";
  map[4]="Structure • Foundation • Order";
  map[5]="Motion • Change • Expansion";
  map[6]="Balance • Care • Resonance";
  map[7]="Mystery • Depth • Insight";
  map[8]="Power • Manifestation • Will";
  map[9]="Completion • Transformation • Unity";
  map[10]="Binary Origin • Mirror Collapse • Double Root (10 often collapses to 1)";
  map[11]="Master Number • Ashtei-Asar-Null (11-null) — special metaphysical index";
  const extended = {
    12:"Dual unity expansion. A 3×4 structural harmonic.",
    13:"Prime transition. Gateway from unity to flux.",
    14:"Stabilized duality. A grounded harmonic of 2 and 7.",
    15:"Creative harmonic. 3×5 pattern synthesis.",
    16:"Squared alignment. 4×4 foundational resonance.",
    17:"Insight prime. Metaphysical breakthrough number.",
    18:"Cycle magnification. 2×9 full-loop resonance.",
    19:"Threshold gate. Reduction path: 19 → 10 → 1.",
    20:"Amplified duality. A stable harmonic reset.",
    21:"Triadic symmetry in expansion. 3×7 unified insight.",
    22:"Master architect. Structural dual-master frequency.",
    23:"Prime reflector. A sharp intuitive signature.",
    24:"Structural harmonic. 6×4 equilibrium grounding.",
    25:"Binary harmonic (5×5). Internal synthesis.",
    26:"Dual equilibrium (2×13). Expanded insight.",
    27:"Triadic completion (3×9). Full cycle magnifier.",
    28:"Foundation of cycles (4×7). Ascension stabilized.",
    29:"Prime completion. High-refinement threshold.",
    30:"Harmonic unity. 3×10 cycle alignment.",
    31:"Prime unity. Intuitive initiation.",
    32:"Binary amplification (2⁵). Structural energy.",
    33:"Master harmonic. Double-resonance creation.",
    34:"Reflective foundation. Structural intuition.",
    35:"Harmonic pivot (5×7). Evolution node.",
    36:"Cycle squared (6×6). Complete equilibrium loop.",
    37:"Prime insight. Sharp metaphysical clarity.",
    38:"Dual equilibrium mirror.",
    39:"Triadic completion against foundation.",
    40:"Stability across cycles (4×10). Structural seal.",
    41:"Prime pillar. Distilled focus.",
    42:"Universal harmonic. 6×7 metaphysical bridge.",
    43:"Prime reflector. Ascended subtlety.",
    44:"Master foundation. Structural master resonance.",
    45:"Harmonic completion (5×9). Creative loop.",
    46:"Equilibrium through polarity.",
    47:"Prime ascendant. High-frequency clarity.",
    48:"Expanded structural loop (6×8).",
    49:"Perfect square resonance (7×7).",
    50:"Half-cycle reset. Midpoint transformation.",
    51:"Creative unity loop (3×17).",
    52:"Dual foundation (4×13).",
    53:"Prime signal. Rare frequency.",
    54:"Tri-completion extension (6×9).",
    55:"Master harmonic (5×11). Inner resonance.",
    56:"Foundation alignment (7×8). Structural ascension.",
    57:"Reflective triad (3×19). Gate frequency.",
    58:"Dual reflective path.",
    59:"Prime threshold. Pre-transformation.",
    60:"Harmonic expansion (6×10). Core synthesis.",
    61:"Prime unity beacon.",
    62:"Dual resonance (2×31).",
    63:"Triadic equilibrium (7×9). Completion amplified.",
    64:"Perfect binary square (2⁶). Foundational power.",
    65:"Harmonic pillar (5×13).",
    66:"Master equilibrium. Dual triad resonance.",
    67:"Prime intuitive extension.",
    68:"Expanded dual stability.",
    69:"Reflected cycle. Completion symmetry.",
    70:"Unified structural ascension (7×10).",
    71:"Prime flame. High metaphysical ignition.",
    72:"Harmonic superstructure (8×9).",
    73:"Prime wisdom. Sharp harmonic clarity.",
    74:"Dual structural resonance.",
    75:"Creative expansion (3×25).",
    76:"Reflective equilibrium.",
    77:"Master ascension. Double 7-gate resonance.",
    78:"Cycle transmutation (6×13).",
    79:"Prime threshold signal.",
    80:"Structural amplification (8×10).",
    81:"Full cycle squared (9×9). Peak completion.",
    82:"Dual prime resonance.",
    83:"Prime expansion node.",
    84:"Structural harmonic (7×12).",
    85:"Harmonic duality (5×17).",
    86:"Equilibrium reflector.",
    87:"Tri-resonant extension.",
    88:"Master expansion. Infinite structural echo.",
    89:"Prime transcendence number.",
    90:"Harmonic completion (9×10).",
    91:"Prime-structured cycle (7×13).",
    92:"Dual expanded foundation.",
    93:"Completion vector (3×31).",
    94:"Dual intuition resonance.",
    95:"Harmonic reflective form (5×19).",
    96:"Expanded equilibrium (6×16).",
    97:"Prime clarity-point.",
    98:"Dual completion (7×14).",
    99:"Tri-completion multiplied. Hypercycle.",
    100:"Unity ascended. 10×10 → reduction to 1 but expanded."
  };
  for(const k in extended) map[k] = extended[k];
  return map;
})();

/* ---------------- Johnson reduction path (compact) ----------------
   - Open infinity: apply Johnson rules (0→1, 19→10, 10→1, 11→11-null→1)
   - Closed infinity: identity except 11→2 (per spec)
--------------------------------------------------------------- */
function johnsonReductionPath(n, infinity){
  const path = [n];
  let current = n;
  for(let i=0;i<12;i++){
    let next = current;
    if(infinity === 'open'){
      if(current === 0) next = 1;
      else if(current === 19) next = 10;
      else if(current === 10) next = 1;
      else if(current === 11){
        // represent the null state explicitly then collapse to 1
        path.push('11-null');
        next = 1;
        path.push(next);
        break;
      } else next = current;
    } else {
      // closed mode: only force 11 -> 2 per user's instruction
      if(current === 11) next = 2;
      else next = current;
    }
    path.push(next);
    if(next === current) break;
    current = next;
  }
  // compact consecutive duplicates
  const compact = [];
  for(let i=0;i<path.length;i++){
    if(i===0 || path[i] !== path[i-1]) compact.push(path[i]);
  }
  return compact;
}

/* ---------------- Numerology reduction (preserve masters unless forced) ---------------- */
function numerologyReduce(input, forceMasters){
  if(!forceMasters && (input === 11 || input === 22 || input === 33)) return input;
  let n = Math.abs(Math.trunc(input));
  while(n > 9){
    n = n.toString().split("").reduce((a,b)=>a+Number(b),0);
    if(!forceMasters && (n === 11 || n === 22 || n === 33)) break;
  }
  return n;
}

/* ---------------- Canvas & drawing ---------------- */
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  const px = Math.min(920, Math.floor(window.innerWidth * 0.78));
  canvas.width = px * 2;
  canvas.height = px * 2;
  canvas.style.width = px + 'px';
  canvas.style.height = px + 'px';
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(2,2);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* Draw state */
let angle = 0;
let currentSides = 6;
let spinSpeed = 0.02;
let targetHueSet = [200,260];
let isDot = false;

/* Dot (superposition) state */
let dot = {
  x:0, y:0, vx:0, vy:0,
  lastColorChange:0, color:'#fff',
  lastTeleport:0, nextTeleport:0,
  lastPulse:0, pulsePhase:0
};

/* Utility */
function hsla(h,s,l,a){ return `hsla(${h}, ${s}%, ${l}%, ${a})`; }

/* Draw frame */
function drawFrame(){
  ctx.clearRect(0,0,canvas.width/2, canvas.height/2);
  const W = parseFloat(canvas.style.width);
  const H = parseFloat(canvas.style.height);
  const cx = W/2, cy = H/2, r = Math.min(W,H)/2 - 18;

  // background subtle vignette
  const bgGrad = ctx.createRadialGradient(cx,cy, r*0.05, cx,cy, r*1.1);
  bgGrad.addColorStop(0, 'rgba(255,255,255,0.02)');
  bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bgGrad; ctx.beginPath(); ctx.arc(cx,cy,r+6,0,Math.PI*2); ctx.fill();

  // core glow
  const glow = ctx.createRadialGradient(cx, cy, 10, cx, cy, r);
  glow.addColorStop(0, hsla(targetHueSet[0],92,62,0.12));
  glow.addColorStop(1, hsla(targetHueSet[1],82,30,0.02));
  ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(cx,cy,r*0.9,0,Math.PI*2); ctx.fill();

  if(isDot){
    // hyper-chaotic superposition dot:
    // frequent random direction jitter, teleports, color changes, trails
    const t = performance.now();

    // color change frequently (100-300ms)
    if(t - dot.lastColorChange > randRange(80,300)){
      const hueChoices = [220,290,45,270,140,30,200,330];
      dot.color = `hsl(${pick(hueChoices)} 95% ${Math.floor(randRange(60,80))}%)`;
      dot.lastColorChange = t;
    }

    // teleport occasionally (every 1000-3000ms)
    if(!dot.nextTeleport) dot.nextTeleport = t + randRange(800,3000);
    if(t > dot.nextTeleport){
      // brief flash collapse
      dot.x = cx + randRange(-r*0.5, r*0.5);
      dot.y = cy + randRange(-r*0.5, r*0.5);
      dot.vx = randRange(-3.5,3.5);
      dot.vy = randRange(-3.5,3.5);
      dot.nextTeleport = t + randRange(700,3000);
    }

    // random spikes and jitter
    dot.vx += randRange(-1.6,1.6);
    dot.vy += randRange(-1.6,1.6);

    // occasional strong spike
    if(Math.random() < 0.03){
      dot.vx += randRange(-6,6);
      dot.vy += randRange(-6,6);
    }

    // damping and clamp speed
    dot.vx *= 0.92; dot.vy *= 0.92;
    dot.x = (dot.x || cx) + dot.vx;
    dot.y = (dot.y || cy) + dot.vy;

    // confine within a radius, bounce
    const dx = dot.x - cx, dy = dot.y - cy, dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > r*0.82){
      dot.x = cx + dx * 0.88;
      dot.y = cy + dy * 0.88;
      dot.vx *= -0.6; dot.vy *= -0.6;
    }

    // draw multiple faint ghost echoes to simulate superposition trail
    for(let i=0;i<3;i++){
      const alpha = 0.08 * (1 - i*0.25);
      const size = 26 - i*6;
      const jitterX = randRange(-i*1.5,i*1.5);
      const jitterY = randRange(-i*1.5,i*1.5);
      ctx.beginPath();
      ctx.fillStyle = dot.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
      ctx.arc(dot.x + jitterX, dot.y + jitterY, size, 0, Math.PI*2);
      ctx.fill();
    }

    // bright core (occasionally white flash)
    if(Math.random() < 0.02) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.arc(dot.x, dot.y, 8 + Math.random()*6, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.fillStyle = dot.color;
      ctx.arc(dot.x, dot.y, 6, 0, Math.PI*2);
      ctx.fill();
    }

  } else {
    // polygon / line drawing with enhanced visibility for many sides
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);
    const n = currentSides;

    if(n === 2){
      // spinning line
      const len = r*0.9;
      // heavy glow
      ctx.beginPath();
      ctx.lineWidth = 20 + Math.min(40, n*0.2);
      ctx.strokeStyle = hsla(targetHueSet[0],95,60,0.14);
      ctx.moveTo(-len/2,0); ctx.lineTo(len/2,0); ctx.stroke();
      // crisp
      ctx.beginPath();
      ctx.lineWidth = 3 + Math.min(6, n*0.05);
      ctx.strokeStyle = `hsl(${targetHueSet[1]} 85% 65%)`;
      ctx.moveTo(-len/2,0); ctx.lineTo(len/2,0); ctx.stroke();
    } else {
      // polygon
      const angleStep = (Math.PI*2)/n;
      const radiusScale = 0.68 + (Math.min(n,100)/100) * 0.06; // slightly bigger for high n
      const strokeBoost = 2 + Math.min(18, Math.floor(n/6)); // thicker outline for many sides
      const glowBoost = 8 + Math.min(36, Math.floor(n/3));
      // path
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const a = -Math.PI/2 + i*angleStep;
        const x = Math.cos(a) * r * radiusScale;
        const y = Math.sin(a) * r * radiusScale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();

      // fill gradient
      const g = ctx.createLinearGradient(-r*radiusScale, -r*radiusScale, r*radiusScale, r*radiusScale);
      g.addColorStop(0, hsla(targetHueSet[0], 92, 62, 0.22));
      g.addColorStop(1, hsla(targetHueSet[1], 82, 38, 0.20));
      ctx.fillStyle = g;
      ctx.fill();

      // breathing glow (pulsing alpha)
      const pulse = 0.06 + 0.04 * Math.sin(Date.now()/500 + n);
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const a = -Math.PI/2 + i*angleStep;
        const x = Math.cos(a) * r * radiusScale;
        const y = Math.sin(a) * r * radiusScale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.lineWidth = glowBoost;
      ctx.strokeStyle = hsla(targetHueSet[0], 95, 60, 0.12 + pulse);
      ctx.stroke();

      // crisp outline
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const a = -Math.PI/2 + i*angleStep;
        const x = Math.cos(a) * r * radiusScale;
        const y = Math.sin(a) * r * radiusScale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.lineWidth = Math.max(1.6, strokeBoost * 0.12);
      ctx.strokeStyle = `hsl(${targetHueSet[1]} 88% 72%)`;
      ctx.stroke();
    }
    ctx.restore();
  }

  // advance rotation
  angle += spinSpeed;
  if(angle > Math.PI*200000) angle = angle % (Math.PI*2);
  requestAnimationFrame(drawFrame);
}
requestAnimationFrame(drawFrame);

/* ---------------- UI wiring ---------------- */
const numInput = document.getElementById('num');
const modeSelect = document.getElementById('modeSelect');
const infinitySelect = document.getElementById('infinitySelect');
const forceMastersChk = document.getElementById('forceMasters');
const resultBox = document.getElementById('resultBox');
const metaBox = document.getElementById('metaBox');

/* Compute final used for geometry */
function computeFinal(original){
  const mode = modeSelect.value;
  const infinity = infinitySelect.value;
  const forceMasters = forceMastersChk.checked;

  if(mode === 'numerology'){
    const numer = numerologyReduce(original, forceMasters);
    const jPath = johnsonReductionPath(original, infinity);
    return { final: numer, johnsonPath: jPath, numerology: numer };
  } else {
    // johnson mode
    const path = johnsonReductionPath(original, infinity);
    // final numeric (handle '11-null' string by taking numeric next value if present)
    let final = path[path.length-1];
    if(final === '11-null'){
      // fallback to 1 (path function inserts 1 after 11-null)
      final = 1;
    }
    if(typeof final !== 'number') final = Number(final) || 1;
    return { final, johnsonPath: path };
  }
}

/* Update visuals and UI text */
function updateAll(){
  const raw = numInput.value;
  if(raw === "" || raw === null){ resultBox.textContent = 'Result will appear here.'; metaBox.textContent = 'Metaphysical description will appear here.'; return; }
  let original = clampNum(raw, 0, 100);

  const comp = computeFinal(original);
  const finalForShape = comp.final;
  const johnsonPath = comp.johnsonPath || [];
  const mode = modeSelect.value;
  const infinity = infinitySelect.value;

  // shape decision
  if(finalForShape === 1){ isDot = true; currentSides = 1; } else { isDot = false; currentSides = Math.max(2, finalForShape); }

  // spin speed: base mapping then doubled, capped
  const minSpeed = 0.002;
  const maxSpeed = 0.35;
  const baseSpeed = minSpeed + ((finalForShape / 100) * (maxSpeed - minSpeed));
  let doubled = baseSpeed * 2.0;
  // to avoid unusable speeds, cap to 1.2 rad/frame (still very fast)
  spinSpeed = Math.min(1.2, doubled);

  // color hue mapping
  const h1 = Math.round((finalForShape * 137.508) % 360);
  const h2 = (h1 + 72) % 360;
  targetHueSet = [h1, h2];

  // reset dot state if switching to dot
  if(isDot){
    dot.x = 0; dot.y = 0; dot.vx = randRange(-4,4); dot.vy = randRange(-4,4);
    dot.lastColorChange = 0; dot.nextTeleport = performance.now() + randRange(500,2000);
  }

  // Johnson result & path
  const johnsonResult = (johnsonPath && johnsonPath.length > 0) ? johnsonPath[johnsonPath.length-1] : original;
  const johnsonPathStr = (johnsonPath || []).join(' → ');

  const modeLine = mode === 'johnson' ? 'Johnson Mode' : `Numerology Mode (force masters: ${forceMastersChk.checked ? 'ON' : 'OFF'})`;

  resultBox.textContent =
`Input: ${original}
Johnson Reduction (path): ${johnsonPathStr}
Johnson Reduction Result: ${johnsonResult}
Mode used for shape: ${modeLine}
Infinity Mode: ${infinity === 'open' ? 'Open' : 'Closed'}
Final value used for geometry: ${finalForShape}
Spin speed (rad/frame): ${spinSpeed.toFixed(3)}`;

  const metaText = `${metaphysicalMap[original] || 'No mapped description.'}

Johnson reduction result: ${johnsonResult}
Johnson reduction path: ${johnsonPathStr}
Shape sides used: ${isDot ? 'dot (1)' : currentSides}
Spin speed (rad/frame): ${spinSpeed.toFixed(3)}`;

  metaBox.textContent = metaText;
  canvas.setAttribute('aria-label', `Visualizing ${original}, final ${finalForShape}`);
}

/* Event wiring */
numInput.addEventListener('input', (e)=>{ const v=e.target.value; if(v === ''){ updateAll(); return; } if(!/^\d*$/.test(String(v))){ e.target.value = v.replace(/[^\d]/g,''); } updateAll(); });
modeSelect.addEventListener('change', updateAll);
infinitySelect.addEventListener('change', updateAll);
forceMastersChk.addEventListener('change', updateAll);

/* Sidebar controls */
const fullSidebar = document.getElementById('fullSidebar');
const overlay = document.getElementById('overlay');
const openSidebarBtn = document.getElementById('openSidebarBtn');
const closeSidebarBtn = document.getElementById('closeSidebarBtn');
function openFullSidebar(){ fullSidebar.classList.add('open'); overlay.classList.add('show'); fullSidebar.setAttribute('aria-hidden','false'); }
function closeFullSidebar(){ fullSidebar.classList.remove('open'); overlay.classList.remove('show'); fullSidebar.setAttribute('aria-hidden','true'); }
openSidebarBtn.addEventListener('click', openFullSidebar);
closeSidebarBtn.addEventListener('click', closeFullSidebar);
overlay.addEventListener('click', closeFullSidebar);
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeFullSidebar(); });

/* initialize */
numInput.value = 19;
updateAll();
</script>
</body>
</html>
